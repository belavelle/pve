#!/usr/bin/env bash
set -Eeuo pipefail

REPO_RAW_BASE_DEFAULT="https://raw.githubusercontent.com/belavelle/pve/refs/heads/main"
REPO_RAW_BASE="${REPO_RAW_BASE:-$REPO_RAW_BASE_DEFAULT}"

DOMAIN_DEFAULT="duckdns.org"
DOMAIN="${DOMAIN:-$DOMAIN_DEFAULT}"
FORCE_HTTP="${FORCE_HTTP:-1}"

log()  { echo -e "\033[1;32m[INFO]\033[0m $*"; }
warn() { echo -e "\033[1;33m[WARN]\033[0m $*"; }
err()  { echo -e "\033[1;31m[ERR ]\033[0m $*" >&2; }
die()  { err "$*"; exit 1; }

fetch() { curl -fsSL "$1" || die "Failed to fetch: $1"; }
source_remote() { source <(fetch "$1"); }

source_remote "${REPO_RAW_BASE}/lib/pve-lxc-lib.sh"
source_remote "${REPO_RAW_BASE}/inventory.sh"

load_module() { source_remote "${REPO_RAW_BASE}/services/$1.sh"; }

deploy_one() {
  local svc="$1" ct="$2" host="$3" ip_cfg="$4"
  
  validate_service_name "$svc"
  validate_ct_id "$ct"
  validate_hostname "$host"
  
  load_module "$svc"
  pve_require_base_cmds

  local ip_norm
  ip_norm="$(pve_normalize_ip "$ip_cfg")"

  svc_defaults "$svc"

  if ! pve_ct_exists "$ct"; then
    pve_ct_create_privileged "$ct" "$host" "$PVE_STORAGE" "$DISK_GB" "$MEM_MB" "$SWAP_MB" "$CORES" \
      "$PVE_BRIDGE" "$ip_norm" "$PVE_GATEWAY" "$PVE_DNS" "$PVE_OSTEMPLATE"
  fi

  pve_ct_ensure_started "$ct"
  ct_set_root_password "$ct" "${PVE_ROOT_PASSWORD:-}"
  ct_install_base_tools "$ct"
  ct_install_docker_debian "$ct"

  local stack_dir="/opt/stacks/${svc}"
  pct_exec "$ct" "install -d '$stack_dir'"
  svc_compose "$svc" | ct_write_file_stdin "$ct" "$stack_dir/docker-compose.yml"

  if declare -F svc_env >/dev/null; then
    svc_env "$svc" | ct_write_file_stdin "$ct" "$stack_dir/.env"
  fi

  ct_stack_up "$ct" "$stack_dir"
}

destroy_one() {
  local svc="$1" ct="$2"
  
  validate_service_name "$svc"
  validate_ct_id "$ct"
  pve_require_base_cmds
  
  if ! pve_ct_exists "$ct"; then
    warn "Service $svc (CT $ct) does not exist, skipping"
    return 0
  fi
  
  warn "About to destroy service: $svc (CT $ct)"
  warn "All data and volumes will be permanently removed!"
  echo -n "Are you sure? (yes/no): "
  read -r response
  
  if [[ "$response" != "yes" ]]; then
    log "Skipping $svc (CT $ct)"
    return 0
  fi
  
  pve_ct_destroy "$ct"
}

status_one() {
  local svc="$1" ct="$2"
  local status ip uptime stats cpu mem
  
  status="$(pve_ct_get_status "$ct")"
  
  if [[ "$status" == "not-found" ]]; then
    printf "%-10s %-4s %-8s %-15s %-6s %-12s %-10s\n" "$svc" "$ct" "missing" "-" "-" "-" "-"
    return 0
  fi
  
  if [[ "$status" == "running" ]]; then
    ip="$(pve_ct_get_ipv4 "$ct" || echo "-")"
    uptime="$(pve_ct_get_uptime "$ct")"
    stats="$(pve_ct_get_stats "$ct")"
    cpu="${stats%%|*}"
    mem="${stats##*|}"
  else
    ip="-"
    uptime="-"
    cpu="-"
    mem="-"
  fi
  
  printf "%-10s %-4s %-8s %-15s %-6s %-12s %-10s\n" "$svc" "$ct" "$status" "$ip" "$cpu" "$mem" "$uptime"
}

show_status() {
  pve_require_base_cmds
  
  printf "%-10s %-4s %-8s %-15s %-6s %-12s %-10s\n" "SERVICE" "CT" "STATUS" "IP" "CPU" "MEMORY" "UPTIME"
  printf "%-10s %-4s %-8s %-15s %-6s %-12s %-10s\n" "----------" "----" "--------" "---------------" "------" "------------" "----------"
  
  for entry in "${SERVICES[@]}"; do
    IFS=: read -r svc ct host ip <<<"$entry"
    status_one "$svc" "$ct"
  done
}

render_caddyfile() {
  local tmp; tmp="$(mktemp)"
  echo "# Autogenerated Caddyfile" > "$tmp"

  for entry in "${SERVICES[@]}"; do
    IFS=: read -r svc ct host ip <<<"$entry"
    [[ "$svc" == "caddy" ]] && continue
    load_module "$svc"
    declare -F svc_caddy_port >/dev/null || continue
    local port="$(svc_caddy_port)"
    local ipaddr="$(pve_ct_get_ipv4 "$ct")"
    local site="http://${svc}.${DOMAIN}"
    cat >>"$tmp" <<EOF
${site} {
  reverse_proxy ${ipaddr}:${port}
}
EOF
  done

  load_module caddy
  local ct
  for entry in "${SERVICES[@]}"; do
    IFS=: read -r svc ct host ip <<<"$entry"
    [[ "$svc" == "caddy" ]] && break
  done

  local stack_dir="/opt/stacks/caddy"
  pct_exec "$ct" "install -d '$stack_dir'"
  svc_compose caddy | ct_write_file_stdin "$ct" "$stack_dir/docker-compose.yml"
  ct_write_file_stdin "$ct" "$stack_dir/Caddyfile" <"$tmp"
  pct_exec "$ct" "cd '$stack_dir' && docker compose up -d"
}

main() {
  [[ $# -gt 0 ]] || exit 1
  
  if [[ "$1" == "render-caddy" ]]; then
    render_caddyfile
    exit 0
  fi
  
  if [[ "$1" == "status" ]]; then
    show_status
    exit 0
  fi
  
  if [[ "$1" == "destroy" ]]; then
    shift
    [[ $# -gt 0 ]] || die "Usage: $0 destroy <service|all>"
    
    for arg in "$@"; do
      for entry in "${SERVICES[@]}"; do
        IFS=: read -r svc ct host ip <<<"$entry"
        [[ "$svc" == "$arg" || "$arg" == "all" ]] && destroy_one "$svc" "$ct"
      done
    done
    exit 0
  fi

  for arg in "$@"; do
    for entry in "${SERVICES[@]}"; do
      IFS=: read -r svc ct host ip <<<"$entry"
      [[ "$svc" == "$arg" || "$arg" == "all" ]] && deploy_one "$svc" "$ct" "$host" "$ip"
    done
  done

  render_caddyfile
}

main "$@"
